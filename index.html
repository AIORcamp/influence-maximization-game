<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>流量密碼戰 (學生版)</title>
<style>
    body {
        font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
        margin: 0; padding: 0;
        background-color: #f0f2f5;
        display: flex; flex-direction: column;
        height: 100vh; overflow: hidden; touch-action: none;
    }

    header {
        background-color: #2c3e50; color: white; padding: 8px 15px;
        display: flex; justify-content: space-between; align-items: center;
        height: 50px; flex-shrink: 0;
    }
    .title h1 { margin: 0; font-size: 1.1rem; }
    .title small { font-size: 0.75rem; color: #bdc3c7; display: block;}

    .seed-ctrl {
        display: flex; align-items: center; background: rgba(255,255,255,0.1);
        padding: 4px 8px; border-radius: 4px;
    }
    .seed-ctrl input {
        width: 60px; border: none; border-radius: 2px; 
        text-align: center; padding: 6px; font-weight: bold; font-size: 1rem;
    }
    .seed-ctrl button {
        margin-left: 5px; padding: 6px 12px; cursor: pointer;
        background: #3498db; color: white; border: none; border-radius: 2px;
        font-weight: bold;
    }

    #canvas-wrapper {
        flex: 1; position: relative; background: #fff; width: 100%; overflow: hidden;
        cursor: grab;
        min-height: 300px;
    }
    #canvas-wrapper:active { cursor: grabbing; }
    canvas { display: block; width: 100%; height: 100%; }

    /* 面板樣式 */
    #data-panel {
        position: absolute;
        top: 50px; left: 10px;
        width: 160px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #7f8c8d;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        display: flex; flex-direction: column;
        z-index: 90;
        overflow: hidden;
        transition: height 0.3s;
        opacity: 0; pointer-events: none; transform: scale(0.9);
    }
    #data-panel.visible { opacity: 1; pointer-events: auto; transform: scale(1); }

    #panel-header {
        background: #34495e; color: white; padding: 8px 10px;
        cursor: move; font-size: 0.85rem; font-weight: bold;
        display: flex; justify-content: space-between; align-items: center;
        user-select: none;
    }
    
    .btn-min {
        background: none; border: 1px solid rgba(255,255,255,0.5);
        color: white; border-radius: 4px; width: 20px; height: 20px;
        display: flex; align-items: center; justify-content: center;
        cursor: pointer; font-size: 12px;
    }

    #panel-content {
        max-height: 250px; overflow-y: auto; padding: 0;
        transition: max-height 0.3s ease;
    }
    #data-panel.minimized #panel-content { max-height: 0; }
    
    table.data-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
    table.data-table th { background: #ecf0f1; text-align: center; padding: 4px; position: sticky; top: 0; }
    table.data-table td { border-bottom: 1px solid #eee; text-align: center; padding: 4px 0; }
    .row-seed { background-color: #fab1a0; }
    .row-active { background-color: #ff7675; color: white; }
    .row-wa { background-color: #ffeaa7; }

    .footer {
        background: white; border-top: 1px solid #ccc; padding: 8px;
        flex-shrink: 0; display: flex; flex-direction: column; gap: 6px;
    }

    .legend {
        display: flex; gap: 8px; font-size: 0.8rem; justify-content: center; color: #666; flex-wrap: wrap;
    }
    .legend span { display: flex; align-items: center; gap: 4px; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

    .status-bar {
        display: flex; justify-content: space-between;
        background: #f1f2f6; padding: 8px; border-radius: 5px;
        font-size: 0.9rem; color: #555; font-weight: bold;
    }
    .status-bar b { color: #e74c3c; font-size: 1.1rem; }

    .btn-group { display: flex; gap: 8px; height: 45px; }
    .btn {
        flex: 1; border: none; border-radius: 6px;
        font-size: 1rem; font-weight: bold; color: white; cursor: pointer;
    }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .btn-reset { background: #95a5a6; flex: 0.4; }
    .btn-toggle { background: #34495e; flex: 0.4; font-size: 0.9rem; }
    /* AI 按鈕已移除 */
    .btn-start { background: #27ae60; flex: 1; }

    #toast {
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.8); color: white; padding: 10px 20px;
        border-radius: 20px; font-size: 1rem; opacity: 0; pointer-events: none; transition: opacity 0.3s;
        z-index: 100; text-align: center; width: 80%;
    }
</style>
</head>
<body>

<header>
    <div class="title">
        <h1>流量密碼戰</h1>
        <small>尋找關鍵 3 人 (學生版)</small>
    </div>
    <div class="seed-ctrl">
        <input type="number" id="seedInput" value="2026">
        <button onclick="reloadMap()">載入</button>
    </div>
</header>

<div id="canvas-wrapper">
    <canvas id="gameCanvas"></canvas>
    
    <div id="data-panel">
        <div id="panel-header">
            <span>數據驗算</span>
            <button class="btn-min" onclick="toggleMinimize(event)">_</button>
        </div>
        <div id="panel-content">
            <table class="data-table">
                <thead><tr><th>ID</th><th>H</th><th>接收量</th></tr></thead>
                <tbody id="data-body"></tbody>
            </table>
        </div>
    </div>

    <div id="toast">請選擇 3 個節點</div>
</div>

<div class="footer">
    <div class="legend">
        <span><i class="dot" style="background:#ecf0f1; border:1px solid #bdc3c7"></i>未啟動</span>
        <span><i class="dot" style="background:#e74c3c"></i>種子</span>
        <span><i class="dot" style="background:#ff7675"></i>擴散</span>
        <span>藍字:接收量</span>
    </div>
    <div class="status-bar">
        <span>選取: <b id="ui-seeds">0</b>/3</span>
        <span>總擴散數: <b id="ui-active">0</b>/16</span>
    </div>
    <div class="btn-group">
        <button class="btn btn-reset" onclick="resetGame()">重置</button>
        <button class="btn btn-toggle" onclick="toggleTable()">數據表</button>
        <button class="btn btn-start" id="btn-start" onclick="startSim()" disabled>開始擴散</button>
    </div>
</div>

<script>
// --- 參數 ---
const NODE_COUNT = 16; 
const NODE_RADIUS = 24; 
const MAX_SEEDS = 3;

// --- 變數 ---
let canvas, ctx;
let width, height;
let nodes = []; 
let seeds = new Set();
let isSimulating = false;
let mySeed = 2026;

// 拖曳控制
let dragNode = null;
let dragStartPos = {x:0, y:0};
let isDraggingNode = false; 

// --- 隨機數 (保持與教師版一致) ---
function seededRandom() {
    mySeed = (mySeed * 9301 + 49297) % 233280;
    return mySeed / 233280;
}

window.onload = function() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    window.addEventListener('resize', resizeCanvas);
    
    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, {passive: false});
    canvas.addEventListener('touchmove', onPointerMove, {passive: false});
    window.addEventListener('touchend', onPointerUp);

    initDraggablePanel();

    setTimeout(() => {
        resizeCanvas();
        reloadMap();
        requestAnimationFrame(loop);
    }, 100);
};

function resizeCanvas() {
    const wrapper = document.getElementById('canvas-wrapper');
    width = canvas.width = wrapper.clientWidth || 300;
    height = canvas.height = wrapper.clientHeight || 300;
}

function toggleTable() {
    const panel = document.getElementById('data-panel');
    panel.classList.toggle('visible');
    updateTable();
}

function toggleMinimize(e) {
    e.stopPropagation();
    const panel = document.getElementById('data-panel');
    const btn = e.target;
    if(panel.classList.contains('minimized')) {
        panel.classList.remove('minimized');
        btn.innerText = '_';
    } else {
        panel.classList.add('minimized');
        btn.innerText = '□';
    }
}

function initDraggablePanel() {
    const panel = document.getElementById('data-panel');
    const header = document.getElementById('panel-header');
    let isPanelDragging = false;
    let startX, startY, initialLeft, initialTop;

    const startDrag = (e) => {
        isPanelDragging = true;
        let clientX = e.clientX || e.touches[0].clientX;
        let clientY = e.clientY || e.touches[0].clientY;
        startX = clientX;
        startY = clientY;
        initialLeft = panel.offsetLeft;
        initialTop = panel.offsetTop;
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', onDrag, {passive: false});
        document.addEventListener('touchend', stopDrag);
    };

    const onDrag = (e) => {
        if(!isPanelDragging) return;
        e.preventDefault();
        let clientX = e.clientX || e.touches[0].clientX;
        let clientY = e.clientY || e.touches[0].clientY;
        let dx = clientX - startX;
        let dy = clientY - startY;
        panel.style.left = (initialLeft + dx) + 'px';
        panel.style.top = (initialTop + dy) + 'px';
    };

    const stopDrag = () => {
        isPanelDragging = false;
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('touchend', stopDrag);
    };

    header.addEventListener('mousedown', startDrag);
    header.addEventListener('touchstart', startDrag, {passive: false});
}

function reloadMap() {
    let inputVal = document.getElementById('seedInput').value;
    mySeed = parseInt(inputVal) || 2026;
    resetGameData();
    
    // 1. 生成節點
    nodes = [];
    let attempts = 0;
    let padding = NODE_RADIUS * 1.5;
    let safeW = width - 2 * padding;
    let safeH = height - 2 * padding;

    while(nodes.length < NODE_COUNT && attempts < 2000) {
        attempts++;
        let x = padding + seededRandom() * safeW;
        let y = padding + seededRandom() * safeH;
        
        let overlap = false;
        for(let n of nodes) {
            if(Math.hypot(n.x - x, n.y - y) < NODE_RADIUS * 3) {
                overlap = true; break;
            }
        }
        if(!overlap) {
            nodes.push({
                id: nodes.length + 1,
                x: x, y: y,
                power: Math.floor(seededRandom() * 9) + 1, 
                threshold: Math.floor(seededRandom() * 4) + 2, 
                currentInput: 0,
                state: 'normal',
                neighbors: []
            });
        }
    }

    // 2. 連通圖
    let connected = [0]; 
    let unconnected = []; 
    for(let i=1; i<NODE_COUNT; i++) unconnected.push(i);
    let rawPairs = [];

    while(unconnected.length > 0) {
        let uIdx = Math.floor(seededRandom() * connected.length);
        let u = connected[uIdx];
        let bestVIdx = -1;
        let minDist = Infinity;
        
        for(let k=0; k<5; k++) {
             let tryIdx = Math.floor(seededRandom() * unconnected.length);
             let vCand = unconnected[tryIdx];
             let d = Math.hypot(nodes[u].x - nodes[vCand].x, nodes[u].y - nodes[vCand].y);
             if(d < minDist) { minDist = d; bestVIdx = tryIdx; }
        }
        if(bestVIdx === -1) bestVIdx = 0;
        
        let v = unconnected[bestVIdx];
        rawPairs.push({u: u, v: v});
        connected.push(v);
        unconnected.splice(bestVIdx, 1);
    }

    for(let i=0; i<NODE_COUNT; i++) {
        let u = i;
        let v = Math.floor(seededRandom() * NODE_COUNT);
        if(u !== v && !rawPairs.some(p => (p.u===u && p.v===v) || (p.u===v && p.v===u))) {
             if(Math.hypot(nodes[u].x - nodes[v].x, nodes[u].y - nodes[v].y) < width * 0.4) {
                 rawPairs.push({u: u, v: v});
             }
        }
    }

    let adj = Array.from({length: NODE_COUNT}, () => []);
    rawPairs.forEach(p => { adj[p.u].push(p.v); adj[p.v].push(p.u); });

    for(let i=0; i<NODE_COUNT; i++) {
        let degree = adj[i].length;
        if(degree === 0) continue;
        let weights = [];
        let sum = 0;
        for(let k=0; k<degree; k++) {
            let r = Math.floor(seededRandom() * 10) + 1; 
            weights.push(r);
            sum += r;
        }
        for(let k=0; k<degree; k++) {
            let targetId = adj[i][k];
            let w = weights[k] / sum;
            nodes[i].neighbors.push({
                target: nodes[targetId], weight: w, active: false 
            });
        }
    }
    updateTable();
    showToast(`地圖 ${inputVal} 已載入 (學生版)`);
}

function resetGameData() {
    isSimulating = false;
    seeds.clear();
    if(nodes.length > 0) {
        nodes.forEach(n => {
            n.state = 'normal';
            n.currentInput = 0;
            n.neighbors.forEach(e => e.active = false);
        });
    }
    updateUI();
    updateTable();
}

function updateTable() {
    const tbody = document.getElementById('data-body');
    if(!tbody) return;
    const panel = document.getElementById('data-panel');
    if(!panel.classList.contains('visible')) return;

    let html = '';
    let sortedNodes = [...nodes].sort((a,b) => a.id - b.id);

    sortedNodes.forEach(n => {
        let rowClass = '';
        let inputDisplay = n.currentInput.toFixed(1);
        
        if(n.state === 'seed') {
            rowClass = 'row-seed';
            inputDisplay = '(種子)';
        } else if(n.state === 'active') {
            rowClass = 'row-active';
        } else if(n.currentInput > 0) {
            rowClass = 'row-wa';
        }

        html += `<tr class="${rowClass}">
            <td><b>${n.id}</b></td>
            <td>${n.threshold}</td>
            <td>${inputDisplay}</td>
        </tr>`;
    });
    tbody.innerHTML = html;
}

// --- 互動 ---
function getPointerPos(e) {
    let rect = canvas.getBoundingClientRect();
    let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    let y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    return {x, y};
}

function onPointerDown(e) {
    if(isSimulating) return;
    let pos = getPointerPos(e);
    for(let n of nodes) {
        let d = Math.hypot(pos.x - n.x, pos.y - n.y);
        if(d < NODE_RADIUS * 1.5) {
            dragNode = n;
            dragStartPos = {x: pos.x, y: pos.y};
            isDraggingNode = false;
            return;
        }
    }
}

function onPointerMove(e) {
    if(!dragNode) return;
    e.preventDefault(); 
    let pos = getPointerPos(e);
    if(!isDraggingNode) {
        let distMoved = Math.hypot(pos.x - dragStartPos.x, pos.y - dragStartPos.y);
        if(distMoved > 5) isDraggingNode = true;
    }
    if(isDraggingNode) {
        let pad = NODE_RADIUS;
        dragNode.x = Math.max(pad, Math.min(width - pad, pos.x));
        dragNode.y = Math.max(pad, Math.min(height - pad, pos.y));
    }
}

function onPointerUp(e) {
    if(dragNode) {
        if(!isDraggingNode) toggleSeed(dragNode);
        dragNode = null; isDraggingNode = false;
    }
}

function loop() {
    ctx.fillStyle = '#fff'; 
    ctx.fillRect(0, 0, width, height);

    try {
        nodes.forEach(source => {
            source.neighbors.forEach(edge => {
                drawCurve(source, edge.target, edge.active, edge.weight, false);
            });
        });

        nodes.forEach(n => {
            ctx.beginPath();
            ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI*2);
            ctx.shadowColor = 'rgba(0,0,0,0.15)'; ctx.shadowBlur = 4;
            
            if(n.state === 'seed') {
                ctx.fillStyle = '#e74c3c'; ctx.strokeStyle = '#c0392b';
            } else if(n.state === 'active') {
                ctx.fillStyle = '#ff7675'; ctx.strokeStyle = '#d63031';
            } else if(n.currentInput > 0) {
                ctx.fillStyle = '#ffeaa7'; ctx.strokeStyle = '#fdcb6e';
            } else {
                ctx.fillStyle = '#ecf0f1'; ctx.strokeStyle = '#bdc3c7';
            }
            
            ctx.fill();
            ctx.shadowBlur = 0; ctx.lineWidth = 2; ctx.stroke();

            ctx.fillStyle = '#2d3436';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(n.id, n.x, n.y);

            ctx.fillStyle = '#555';
            ctx.font = 'bold 12px Arial';
            ctx.fillText(`${n.power} | ${n.threshold}`, n.x, n.y + NODE_RADIUS + 12);

            if(n.state !== 'seed' && n.currentInput > 0) {
                ctx.fillStyle = '#0984e3'; 
                ctx.font = 'bold 14px Arial';
                ctx.fillText(`R:${n.currentInput.toFixed(1)}`, n.x, n.y - NODE_RADIUS - 12);
            }
        });

        nodes.forEach(source => {
            source.neighbors.forEach(edge => {
                drawCurve(source, edge.target, edge.active, edge.weight, true);
            });
        });
    } catch (e) {}

    requestAnimationFrame(loop);
}

function drawCurve(source, target, isActive, weight, drawLabelOnly) {
    let dx = target.x - source.x;
    let dy = target.y - source.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < 1) return;

    let midX = (source.x + target.x) / 2;
    let midY = (source.y + target.y) / 2;
    let offset = 35; 
    let normX = -dy / dist;
    let normY = dx / dist;
    let ctrlX = midX + normX * offset;
    let ctrlY = midY + normY * offset;

    if(!drawLabelOnly) {
        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.quadraticCurveTo(ctrlX, ctrlY, target.x, target.y);
        if(isActive) {
            ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 4;
        } else {
            ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1.5;
        }
        ctx.stroke();

        let t = 0.85; let invT = 1-t;
        let arrowX = invT*invT*source.x + 2*invT*t*ctrlX + t*t*target.x;
        let arrowY = invT*invT*source.y + 2*invT*t*ctrlY + t*t*target.y;
        let tanX = 2*invT*(ctrlX-source.x) + 2*t*(target.x-ctrlX);
        let tanY = 2*invT*(ctrlY-source.y) + 2*t*(target.y-ctrlY);
        drawArrowHead(ctx, arrowX, arrowY, Math.atan2(tanY, tanX));
    } else {
        let t = 0.4; let invT = 1-t;
        let labelX = invT*invT*source.x + 2*invT*t*ctrlX + t*t*target.x;
        let labelY = invT*invT*source.y + 2*invT*t*ctrlY + t*t*target.y;
        let txt = Math.round(weight * 100) + "%";
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        let metrics = ctx.measureText(txt);
        let w = metrics.width + 4;
        ctx.fillRect(labelX - w/2, labelY - 8, w, 16);
        ctx.fillStyle = '#555';
        ctx.font = '11px Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(txt, labelX, labelY);
    }
}

function drawArrowHead(ctx, x, y, angle) {
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-7, -3.5); ctx.lineTo(-7, 3.5);
    ctx.closePath(); ctx.fillStyle = ctx.strokeStyle; ctx.fill(); ctx.restore();
}

function toggleSeed(n) {
    if(seeds.has(n)) {
        seeds.delete(n);
        n.state = 'normal';
        n.currentInput = 0;
    } else {
        if(seeds.size >= MAX_SEEDS) { showToast("已達 3 個上限"); return; }
        seeds.add(n);
        n.state = 'seed';
        n.currentInput = n.threshold + 99; 
    }
    updateUI();
    updateTable();
}

function updateUI() {
    document.getElementById('ui-seeds').innerText = seeds.size;
    let active = nodes.filter(n => n.state === 'seed' || n.state === 'active').length;
    document.getElementById('ui-active').innerText = active;
    document.getElementById('btn-start').disabled = (seeds.size === 0);
}

function showToast(msg) {
    let t = document.getElementById('toast');
    t.innerText = msg; t.style.opacity = 1;
    setTimeout(()=>t.style.opacity=0, 2000);
}

async function startSim() {
    isSimulating = true;
    document.querySelectorAll('.btn').forEach(b => b.disabled = true);
    showToast("擴散中...");

    let queue = [...seeds];
    let visitedEdges = new Set();

    while(queue.length > 0) {
        await new Promise(r => setTimeout(r, 800));
        let nextQueue = [];

        for(let source of queue) {
            for(let edge of source.neighbors) {
                let edgeKey = `${source.id}-${edge.target.id}`;
                if(visitedEdges.has(edgeKey)) continue;

                let target = edge.target;
                if(target.state === 'seed') {
                    visitedEdges.add(edgeKey); continue;
                }

                visitedEdges.add(edgeKey);
                edge.active = true;
                target.currentInput += source.power * edge.weight;
            }
        }
        
        nodes.forEach(n => {
            if(n.state === 'normal' && n.currentInput > n.threshold) {
                n.state = 'active';
                nextQueue.push(n);
            }
        });
        queue = nextQueue;
        updateUI();
        updateTable(); 
    }
    showToast("模擬結束");
    document.querySelector('.btn-reset').disabled = false;
    document.querySelector('.btn-toggle').disabled = false;
}

function resetGame() {
    resetGameData();
    document.querySelectorAll('.btn').forEach(b => b.disabled = false);
    document.getElementById('btn-start').disabled = true;
}
</script>
</body>
</html>